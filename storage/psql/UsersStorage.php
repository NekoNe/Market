<?php

include_once __DIR__ . "/../CustomersStorage.php";
include_once __DIR__ . "/../ExecutorsStorage.php";

/*
 *  todo: do not try to access User object fields directly.
 *  Add interface to access them.
 */

class UserPsqlStorage implements CustomersStorage, ExecutorsStorage
{
    private $db;

    private $tableName;
    private $idField = "id";
    private $balanceField = "balance";

    private $userType; // todo: this solution looks like a hack

    public function __construct(PsqlConfig $config, string $tableName, $userType)
    {
        $this->tableName = $tableName;
        $this->userType = $userType;

        $this->db = pg_connect("$config->host $config->port $config->dbname $config->credentials");
        if(!$this->db)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
        // todo: select balance type
        $query =<<<EOF
        CREATE TABLE IF NOT EXISTS {$this->tableName} (
          {$this->idField}     serial primary key,
          {$this->balanceField} numeric(16,0) 
        );
EOF;
        $ret = pg_query($this->db, $query);
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
    }

    public function __destruct()
    {
        pg_close($this->db);
    }

    // todo: this function mutates $customer. how would I show user this object is mutated?
    public function Create(User $user)
    {
        $query =<<<EOF
        INSERT INTO {$this->tableName} ({$this->balanceField})
        VALUES ({$user->balance});
EOF;
        $ret = pg_query($this->db, $query);
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
        /*
         * currval() returns the last value generated by the sequence for the current session.
         * So, no race conditions are possible.
         */
        $query =<<<EOF
            SELECT currval(pg_get_serial_sequence('{$this->tableName}', '{$this->idField}'));
EOF;
        $ret = pg_query($this->db, $query);
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }

        $ret = pg_fetch_result($ret, 0);
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
        $user->id = intval($ret);
    }

    public function Read(string $id): ?User
    {
        $query =<<<EOF
        SELECT * FROM {$this->tableName} WHERE {$this->idField} = {$id};
EOF;
        $ret = pg_query($this->db, $query);
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
        $numRows = pg_numrows($ret);
        if($numRows != 1)
        {
            throw new ObjectNotFoundException("{$this->userType}:{$id}");
        }
        $obj = pg_fetch_object($ret, 0);
        if(!$obj)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
        $customer = new $this->userType();
        $customer->id = $obj->{$this->idField};
        $customer->balance = floatval($obj->{$this->balanceField});

        return $customer;
    }

    // note: UPDATE changes rows order
    public function Update(string $id, callable $updater): ?User
    {
        $customer = $updater(null); // todo: select and update. pass selected user.
        $query =<<<EOF
        UPDATE {$this->tableName} 
            SET {$this->balanceField} = {$customer->balance}
            WHERE {$this->idField} = {$id}
            RETURNING *;
EOF;
        $ret = pg_query($this->db, $query);
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
        $affectedRows = pg_affected_rows($ret);
        if($affectedRows < 1)
        {
            throw new ObjectNotFoundException("{$this->userType}:{$id}");
        }
        else if($affectedRows > 1)
        {
            throw new MarketRuntimeException("USER UPDATE {$this->userType}:{$id} affected rows {$affectedRows}");
        }
        $obj = pg_fetch_object($ret, 0);
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
        $customer = new $this->userType();
        $customer->id = $obj->{$this->idField};
        $customer->balance = floatval($obj->{$this->balanceField});

        return $customer;
    }

    public function Delete(string $id)
    {
        $query =<<<EOF
        DELETE FROM {$this->tableName} WHERE {$this->idField} = {$id};
EOF;
        $ret = pg_query($this->db, $query);
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
        $deleted = pg_affected_rows($ret);
        if($deleted == 0)
        {
            throw new ObjectNotFoundException("{$this->userType}:{$id}");
        }
        else if($deleted > 1)
        {
            throw new MarketRuntimeException("USER UPDATE {$this->userType}:{$id} affected rows {$deleted}");
        }
    }

    // todo: implement pagination
    public function List(int $offset, int $length): UsersList
    {
        $query =<<<EOF
        SELECT * FROM {$this->tableName};
EOF;
        $ret = pg_query($this->db, $query);
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
        $list = new UsersList();
        while($obj = pg_fetch_object($ret))
        {
            $customer = new $this->userType();
            $customer->id = $obj->{$this->idField};
            $customer->balance = $obj->{$this->balanceField};

            $list->addUser($customer);
        }
        return $list;
    }

    public function BeginTransaction()
    {
        $ret = pg_query($this->db, "BEGIN;");
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
    }

    public function CommitTransaction()
    {
        $ret = pg_query($this->db, "COMMIT;");
        if(!$ret)
        {
            throw new DatabaseException(pg_last_error($this->db));
        }
    }
}

